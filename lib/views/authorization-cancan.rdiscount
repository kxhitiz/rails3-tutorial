#### {% title "Autoryzacja — CanCan" %}

# Autoryzacja z CanCan

**CanCan is a simple authorization plugin that offers a lot of flexibility.**
Zamierzamy to sprawdzić, dodając autoryzację do Fortunki z autentykacją.

* [Authorization with CanCan](http://railscasts.com/episodes/192-authorization-with-cancan)
  ([ASCIIcast](http://asciicasts.com/episodes/192-authorization-with-cancan))
* [CanCan](http://github.com/ryanb/cancan) – 
  simple authorization for Rails.

Zaczynamy od sklonowania Fortunki z *Autentykacja z Authlogic*:

    git clone ssh://sigma.ug.edu.pl/~wbzyl/hello/authlogic

i utworzenia nowej gałęzi:

    git checkout -b cancan

na której będziemy eksperymentować z autoryzacją.

Następnie na gałęzi *cancan* podmieniamy w pliku *database.yml* nazwę
bazy danych dla trybu development:

    :::yaml
    development:
      adapter: sqlite3
      database: db/cancan-development.sqlite3
      pool: 5
      timeout: 5000

oraz nazwy baz danych używanych trybach test i production.

Po tych podmianach, migrujemy:

    rake db:migrate

i jesteśmy w miejscu w którym zakończyliśmy zabawę z Authlogic,
ale tym razem jesteśmy na gałęzi **cancan**, a nie na *master*.

Wykorzystamy *cancan* do dodania trzech ról do Fortunki:

* admin — **może** wszystko
* moderator — **może** dodawać nowe i edytować swoje cytaty
* author — może **edytować** i **usuwać** każdy cytat


## Przygotowania

Dopuszczamy sytuację, że użytkownik może mieć kilka ról.

Wszystkie role użytkownika będziemy **kodować** w dodatkowym atrybucie
modelu *User* o nazwie *roles_mask*.

Zaczynamy od dodania kolumny *roles_mask:integer* do tabeli *users*:

    script/generate migration AddRoleRolesMaskToUser roles_mask:integer
    rake db:migrate

Następnie dopisujemy do modelu *User*:

    :::ruby
    class User < ActiveRecord::Base
      attr_accessible :login, :email, :password, :password_confirmation
      attr_accessible :roles

    has_many :fortunes
    
    named_scope :with_role, lambda { 
      |role| {:conditions => "roles_mask & #{2**ROLES.index(role.to_s)} > 0"} 
    }
    
    ROLES = %w[admin moderator author]
    
    def roles=(roles)
      self.roles_mask = (roles & ROLES).map { |r| 2**ROLES.index(r) }.sum
    end
    def roles
      ROLES.reject { |r| ((roles_mask || 0) & 2**ROLES.index(r)).zero? }
    end
    def role?(role)
      roles.include? role.to_s
    end

Do widoku częściowego *users/_form.html.erb* dopisujemy:

    :::html_rails
    <p>
      <%= f.label :roles %><br />
      <% for role in User::ROLES %>
        <%= check_box_tag "user[roles][]", role, @user.roles.include?(role) %>
        <%=h role.humanize %><br />
      <% end %>
      <%= hidden_field_tag "user[roles][]", "" %>
    </p>

I jeszcze komentarz do kodu:
„use of *hidden_field_tag* to workaround 
a limitation in HTML form checkbox”.


Jak to działa? Korzystamy z wirtualnego atrybutu *roles*.


## Powiązania między modelami

Każada fortunka została wpisana przez jakiegoś użytkownika,
a użytkownik mógł wpisać wiele fortunek:

    :::ruby
    belongs_to :user    // model Fortune
    has_many :fortunes  // model User

Migracja:

    script/generate migration AddUserIdToFortune user_id:integer
    rake db:migrate

Dopisujemy identyfikator użytkownika w modelu *Fortune* do
*attr_accessible*:

    :::ruby
    attr_accessible :quotation, :user_id


## Umieszczamy przykładowe dane w bazie

Przykładowe dane wpiszemy w pliku *db/seeds.rb*.
W Railsach jest specjalne zadanie *rake*, które
dane z tego pliku „przepisze” do bazy:

    rake db:seed  # load the seed data from db/seeds.rb

Zaczynamy od umieszczenia w bazie trzech użytkowników:

    User.create :login => 'wlodek', :email => 'matwb@ug.edu.pl', 
      :password=> '1234', :password_confirmation => '1234', 
      :roles => ["admin", "", ""]
    User.create :login => 'renia', :email => 'renia@example.pl', 
      :password=> '1234', :password_confirmation => '1234', 
      :roles => ["", "moderator", ""]
    User.create :login => 'bazylek', :email => 'bazylek@cats.com', 
      :password=> '1234', :password_confirmation => '1234', 
      :roles => ["", "", "author"]

W tej wersji Fortunki skorzystamy z cytatów ze strony
[The Quotations Page](http://www.quotationspage.com/subjects/).
Każdemu użytkownikowi przypiszemy po dwa cytaty:

    Fortune.create :quotation => "Men willingly believe what they wish.",
      :user_id => 1
    Fortune.create :quotation => "I have often regretted my speech, never my silence.",
      :user_id => 1
    Fortune.create :quotation => "All science is either physics or stamp collecting.",
      :user_id => 2
    Fortune.create :quotation => "Nothing shocks me. I'm a scientist.",
      :user_id => 2
    Fortune.create :quotation => "Science is organized knowledge. Wisdom is organized life.",
      :user_id => 3
    Fortune.create :quotation => "Security is a kind of death.",
      :user_id => 3


## Zmiany w layoucie

W główce każdej strony umieścimy login zalogowanego użytkownika.
Informację o zalogowanym użytkowniku znajdziemy w sesji.
Jeśli w widoku strony głównej dopiszemy:

    :::html_rails
    <%= debug(UserSession.find) %>

albo, lepiej:

    :::html_rails
    <%= debug(current_user_session) %>

to po zalogowaniu się do aplikacji i przejściu na stronę główną
powinniśmy zobaczyć co Authlogic zapisał w sesji:

    :::yaml
    --- &id002 !ruby/object:UserSession 
    attempted_record: &id001 !ruby/object:User 
      attributes: 
        ...
        login: wlodek
        email: wbzyl@sigma.ug.edu.pl
        ...
        role: 
        current_login_ip: 127.0.0.1
        id: "2"

Stąd widzimy, że 

    :::ruby
    current_user.login

to login zalogowanego użytkownika.

Zatem dopisujemy w *layout/application.html.erb*
poniżej linka *"Logout"*:

    :::html_rails
    Hello <em><%= current_user.login %></em>


## Zmiany na stronie głównej

Widok z rusztowania to tabelka. Nie wygląda to zbyt ładnie.  
Zamiast tabelki uzyjemy kilku elementów *div*.

W widoku *index.html.erb* przy każdym cytacie
dopiszemy login użytkownika który dodał cytat. 
Oto oryginalny widok:

    :::html_rails
    <table>
      <tr>
        <th>Quotation</th>
      </tr>
      <% for fortune in @fortunes %>
        <tr>
          <td><%=h fortune.quotation %></td>
          <td><%= link_to "Show", fortune %></td>
          <% if logged_in? %>
            <td><%= link_to "Edit", edit_fortune_path(fortune) %></td>
            <td><%= link_to "Destroy", 
                      fortune, :confirm => 'Are you sure?', 
                      :method => :delete %></td>
          <% end %>
        </tr>
      <% end %>
    </table>
    <p><%= link_to "New Fortune", new_fortune_path %></p>

A to widok po liftingu:

    :::html_rails
    <% for fortune in @fortunes %>
      <p><%=h fortune.quotation %></p>
      <p><%= link_to "Show", fortune %>
         <% if logged_in? %>
           | <%= link_to "Edit", edit_fortune_path(fortune) %>
           | <%= link_to "Destroy", fortune, 
                      :confirm => 'Are you sure?', 
                      :method => :delete %>
           (added by <em><%= fortune.user.login %></em>)</p>
         <% end %>
      </p>
    <% end %>
    <p><%= link_to "New Fortune", new_fortune_path %></p>


## TODO: Zmiany w edycji fortunek
 
Do widoku *edit*, dodajemy na razie tylko adminowi
(później też moderatorowi) możliwość zmiany użytkownika,
który dodał cytat.

Użyjemy listy rozwijanej. Dopisujemy do *_form.html.erb*:

    :::html_rails
    <%= f.collection_select :user_id, User.all, :id, :login %>


